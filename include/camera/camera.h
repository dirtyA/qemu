/*
 * QEMU Camera subsystem
 *
 * Copyright 2021-2022 Bytedance, Inc.
 *
 * Authors:
 *   zhenwei pi <pizhenwei@bytedance.com>
 *
 * This work is licensed under the terms of the GNU GPL, version 2 or later.
 * See the COPYING file in the top-level directory.
 */
#ifndef QEMU_CAMERA_H
#define QEMU_CAMERA_H

#include "hw/qdev-properties.h"
#include "hw/qdev-properties-system.h"
#include "qapi/qapi-types-camera.h"
#include "qemu/queue.h"

#define camera_fourcc_code(a, b, c, d) \
                          ((uint32_t)(a) | ((uint32_t)(b) << 8) | \
                          ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))

#define QEMU_CAMERA_PIX_FMT_MJPEG  camera_fourcc_code('M', 'J', 'P', 'G')
#define QEMU_CAMERA_PIX_FMT_YUYV   camera_fourcc_code('Y', 'U', 'Y', 'V')
#define QEMU_CAMERA_PIX_FMT_RGB565 camera_fourcc_code('R', 'G', 'B', 'P')

static inline bool qemu_camera_pixel_supported(uint32_t pixfmt)
{
    /* only process MJPEG & YUYV, may support others in future */
    if ((pixfmt == QEMU_CAMERA_PIX_FMT_MJPEG)
        || (pixfmt == QEMU_CAMERA_PIX_FMT_YUYV)
        || (pixfmt == QEMU_CAMERA_PIX_FMT_RGB565)) {
        return true;
    }

    return false;
}

#define QEMU_CAMERA_FRMSIZE_TYPE_DISCRETE 0x00
#define QEMU_CAMERA_FRMSIZE_TYPE_STEPWISE 0x01

typedef struct QEMUCameraFrameSize {
    uint32_t pixel_format;

    uint32_t type;
    union {
        struct FrameSizeDiscrete {
            uint32_t width;
            uint32_t height;
        } d;

        struct FrameSizeStepwise {
            uint32_t min_width;
            uint32_t max_width;
            uint32_t step_width;
            uint32_t min_height;
            uint32_t max_height;
            uint32_t step_height;
        } s;
    };
} QEMUCameraFrameSize;

typedef struct QEMUCameraFormat {
    uint32_t pixel_format;
    uint32_t width;
    uint32_t height;
} QEMUCameraFormat;

#define QEMU_CAMERA_FRMIVAL_TYPE_DISCRETE 0x00
#define QEMU_CAMERA_FRMIVAL_TYPE_STEPWISE 0x01

typedef struct QEMUCameraFrameInterval {
    uint32_t pixel_format;
    uint32_t width;
    uint32_t height;

    uint32_t type;
    union {
        struct FrameIntervalDiscrete {
            uint32_t numerator;
            uint32_t denominator;
        } d;

        struct FrameIntervalStepwise {
            struct FrameIntervalDiscrete min;
            struct FrameIntervalDiscrete max;
            struct FrameIntervalDiscrete step;
        } s;
    };
} QEMUCameraFrameInterval;

typedef enum QEMUCameraControlType {
    QEMUCameraBrightness,
    QEMUCameraContrast,
    QEMUCameraGain,
    QEMUCameraGamma,
    QEMUCameraHue,
    QEMUCameraHueAuto,
    QEMUCameraSaturation,
    QEMUCameraSharpness,
    QEMUCameraWhiteBalanceTemperature,
    QEMUCameraControlMax
} QEMUCameraControlType;

static const char *QEMUCameraControlTypeStr[] = {
    "Brightness",
    "Contrast",
    "Gain",
    "Gamma",
    "Hue",
    "HueAuto",
    "Saturation",
    "Sharpness",
    "WhiteBalanceTemperature",
    "Max",
};

static inline const char *QEMUCameraControlTypeString(QEMUCameraControlType t)
{
    if (t > QEMUCameraControlMax) {
        return "";
    }

    return QEMUCameraControlTypeStr[t];
}

typedef struct QEMUCameraControl {
    QEMUCameraControlType type;
    int32_t cur;
    int32_t def;
    int32_t min;
    int32_t max;
    int32_t step;
} QEMUCameraControl;

#define TYPE_CAMERADEV "cameradev"

typedef void (*qemu_camera_image_cb) (void *opaque, void *buf, ssize_t avail);

struct QEMUCamera {
    Object parent_obj;

    char *model;
    Cameradev *dev;

    /* camera image buffer to store recent frame */
    QemuMutex image_lock;
    /* sequence number generated by driver */
    uint32_t image_sequence;
    /* frame sequence number currently work on */
    uint32_t image_frames;
    unsigned char *image_addr;
    /* size of buffer */
    ssize_t image_size;
    /* real size of this frame, clear to zero after fully read*/
    ssize_t image_bytes;
    /* offset already read, clear to zero after fully read */
    ssize_t image_pos;
    qemu_camera_image_cb cb_fn;
    void *cb_opaque;

    QLIST_ENTRY(QEMUCamera) list;
};

OBJECT_DECLARE_TYPE(QEMUCamera, QEMUCameraClass, CAMERADEV)

struct QEMUCameraClass {
    ObjectClass parent_class;

    void (*open)(QEMUCamera *camera, Error **errp);

    void (*stream_on)(QEMUCamera *camera, Error **errp);

    void (*stream_off)(QEMUCamera *camera, Error **errp);

    int (*enum_pixel_format)(QEMUCamera *camera, uint32_t *pixfmts,
                             int npixfmt, Error **errp);

    int (*enum_frame_size)(QEMUCamera *camera, uint32_t pixfmt,
                           QEMUCameraFrameSize *frmszs, int nfrmsz,
                           Error **errp);

    int (*enum_frame_interval)(QEMUCamera *camera,
                               const QEMUCameraFormat *format,
                               QEMUCameraFrameInterval *frmivals, int nfrmival,
                               Error **errp);

    int (*set_frame_interval)(QEMUCamera *camera,
                              const QEMUCameraFrameInterval *frmival,
                              Error **errp);

    int (*enum_control)(QEMUCamera *camera, QEMUCameraControl *controls,
                        int ncontrols, Error **errp);

    int (*set_control)(QEMUCamera *camera, const QEMUCameraControl *control,
                       Error **errp);
};

void qemu_camera_new_from_opts(const char *opt);
void qemu_camera_del(QEMUCamera *camera);
const char *qemu_camera_id(QEMUCamera *camera);
QEMUCamera *qemu_camera_by_id(const char *id);

int qemu_camera_enum_pixel_format(QEMUCamera *camera, uint32_t *pixfmts,
                                  int npixfmt, Error **errp);

int qemu_camera_enum_frame_size(QEMUCamera *camera, uint32_t pixfmt,
                                QEMUCameraFrameSize *frmszs, int nfrmsz,
                                Error **errp);

int qemu_camera_enum_frame_interval(QEMUCamera *camera,
                                    const QEMUCameraFormat *format,
                                    QEMUCameraFrameInterval *frmivals,
                                    int nfrmival, Error **errp);

int qemu_camera_set_frame_interval(QEMUCamera *camera,
                                   const QEMUCameraFrameInterval *frmival,
                                   Error **errp);

int qemu_camera_enum_control(QEMUCamera *camera, QEMUCameraControl *controls,
                             int ncontrols, Error **errp);

int qemu_camera_set_control(QEMUCamera *camera,
                            const QEMUCameraControl *control, Error **errp);

void qemu_camera_stream_on(QEMUCamera *camera, qemu_camera_image_cb cb,
                           void *opaque, Error **errp);

void qemu_camera_stream_off(QEMUCamera *camera, Error **errp);

size_t qemu_camera_stream_length(QEMUCamera *camera);

size_t qemu_camera_stream_read(QEMUCamera *camera, const struct iovec *iov,
                               const uint32_t iov_cnt, size_t offset,
                               size_t size);

#endif /* QEMU_CAMERA_H */
